package org.folio.marccat.dao.persistence;

import net.sf.hibernate.Session;
import org.folio.marccat.business.cataloguing.common.Tag;
import org.folio.marccat.business.cataloguing.common.TagImpl;
import org.folio.marccat.business.common.group.*;
import org.folio.marccat.config.log.Log;
import org.folio.marccat.config.log.MessageCatalog;
import org.folio.marccat.exception.*;
import org.folio.marccat.shared.Validation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.Serializable;
import java.util.*;


/**
 * @author paulm
 * @author nbianchini
 * @since 1.0
 */
public abstract class CatalogItem implements Serializable {

  private static final Comparator<Tag> tagComparator =
    (Tag tag1, Tag tag2) -> (tag1.getMarcEncoding().getMarcTag().compareTo(tag2.getMarcEncoding().getMarcTag()));
  protected List<Tag> deletedTags = new ArrayList<>();
  protected ModelItem modelItem;
  protected List<Tag> tags = new ArrayList<>();
  private Log logger = new Log(CatalogItem.class);

  public CatalogItem() {
    super();
  }

  /**
   * This method creates a MarcSlim XML Element for this item
   *
   * @return an Element
   */
  public Document toExternalMarcSlim(Session session) {
    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder documentBuilder;
    Document xmlDocument = null;
    try {
      documentBuilder = documentBuilderFactory.newDocumentBuilder();
      xmlDocument = documentBuilder.newDocument();
    } catch (ParserConfigurationException parserConfigurationException) {
      logger.error("Xml Parser Configuration Exception", parserConfigurationException);
    }
    Element record = xmlDocument.createElement("record");
    for (Object t : tags) {
      Tag tag = (Tag) t;
      logger.debug("appending " + tag);
      record.appendChild(tag.toExternalMarcSlim(xmlDocument, session));
    }
    xmlDocument.appendChild(record);
    return xmlDocument;
  }

  @Deprecated
  public void addAllTags(Tag[] tags) {
    for (int i = 0; i < tags.length; i++) {
      addTag(tags[i]);
    }
  }

  @Deprecated
  public void addDeletedTag(Tag aTag) {
    if (!deletedTags.contains(aTag)) {
      deletedTags.add(aTag);
    }
  }


  public void addTag(Tag newTag) {
    tags.add(newTag);
  }

  abstract public void checkForMandatoryTags() throws MandatoryTagException;

  /**
   * Checks if the specified tag is illegally repeated in the item and throws an exception if so.
   *
   * @param index -- the tag index.
   */
  public void checkRepeatability(final int index) throws DataAccessException, DuplicateTagException {
    final Tag t = getTag(index);
    Validation bv = t.getValidation();
    if (!bv.isMarcTagRepeatable()) {
      getTags().remove(index);
      getTags().sort(tagComparator);
      if (Collections.binarySearch(getTags(), t, tagComparator) >= 0) {
        throw new DuplicateTagException(index);
      }
    }
  }

  /**
   * Finds the first tag occurrence of the given tag number.
   * If a length shorter than 3 is given (e.g. "1"), then the first tag starting with a 1 will be returned.
   *
   * @param s -- the tag number to search.
   */
  public Tag findFirstTagByNumber(final String s) {
    try {
      return getTags().stream().filter(tag -> tag.getMarcEncoding().getMarcTag().startsWith(s)).findFirst().orElse(null);
    } catch (Exception e) {
      return null;
    }
  }

  /**
   * Finds the first tag occurrence of the given tag number.
   * If a length shorter than 3 is given (e.g. "1"), then the first tag starting with a 1 will be returned.
   *
   * @param s -- the tag number to search.
   */
  public Tag findFirstTagByNumber(final String s, final Session session) {
    try {
      return getTags().stream().filter(tag -> tag.getMarcEncoding(session).getMarcTag().startsWith(s)).findFirst().orElse(null);
    } catch (Exception e) {
      return null;
    }
  }

  /**
   * @return the Amicus number for the item (aut or bib)
   */
  public Integer getAmicusNumber() {
    return getItemEntity().getAmicusNumber();
  }

  /**
   * @return tags to delete.
   */
  public List<Tag> getDeletedTags() {
    return deletedTags;
  }

  public abstract ItemEntity getItemEntity();

  public abstract void setItemEntity(ItemEntity item);

  public ModelItem getModelItem() {
    return modelItem;
  }


  /**
   * Sets model item associated to item.
   *
   * @param model -- the model to set.
   * @throws DataAccessException in
   */
  public void setModelItem(final Model model) {
    if (this.modelItem == null) {
      this.modelItem = new BibliographicModelItem();
      this.modelItem.markNew();
    }
    this.modelItem.setItem(this.getAmicusNumber());
    this.modelItem.setModel(model);
    this.modelItem.setRecordFields(model.getRecordFields());
  }

  public int getNumberOfTags() {
    return tags.size();
  }

  public Tag getTag(int i) {
    return tags.get(i);
  }

  public abstract TagImpl getTagImpl();

  public List<Tag> getTags() {
    return tags;
  }

  public void setTags(List<Tag> set) {
    tags = set;
  }

  abstract public int getUserView();

  /**
   * @return the verification level of item entity.
   */
  public char getVerificationLevel() {
    return getItemEntity().getVerificationLevel();
  }

  public void setVerificationLevel(char verificationLevel) {
    getItemEntity().setVerificationLevel(verificationLevel);
  }

  /**
   * remove a tag from the deletedTags list (by Object)
   */
  public void removeDeletedTag(Tag tag) {
    deletedTags.remove(tag);
  }

  /**
   * remove a tag from the Item (by Object)
   */
  public void removeTag(Tag tag) {
    tags.remove(tag);
  }


  /**
   * Replacing old tag with a new one in the bibItem.
   */
  public void setTag(Tag oldTag, Tag newTag) {
    if (getAmicusNumber() != null) {
      newTag.setItemNumber(getAmicusNumber());
    }
    tags.set(tags.indexOf(oldTag), newTag);
  }

  /**
   * Sorting of tags.
   */
  @SuppressWarnings("unchecked")
  public void sortTags() {
    try {

      final LinkedHashMap<Object, TagContainer> groupsHashMap = populateGroups();
      List<TagContainer> tagContainers = new ArrayList<>(groupsHashMap.values());
      tagContainers.sort(new GroupComparator());
      final List<Tag> tagSet = unlist(tagContainers);
      setTags(tagSet);
    } catch (MarcCorrelationException e) {
      logger.info(MessageCatalog._00017_MARC_CORRELATION_SORTING);
    } catch (DataAccessException e) {
      logger.info(MessageCatalog._00010_DATA_ACCESS_FAILURE);
    }
  }

  /**
   * Puts the tags back in order by pre-ordering the groups based on the sequence number.
   *
   * @param tagContainers -- list of tag containers.
   * @return list of ordered tags.
   */
  private List<Tag> unlist(final List<TagContainer> tagContainers) {
    final List<Tag> tagSet = new ArrayList<>();
    tagContainers.forEach(item -> {
      if (item instanceof Tag)
        tagSet.add((Tag) item);
      else {
        item.sort();
        tagSet.addAll(item.getList());
      }
    });
    return tagSet;
  }

  /**
   * Rearrange the tags in groups.
   *
   * @return
   * @throws DataAccessException in case of data access failure.
   */
  private LinkedHashMap<Object, TagContainer> populateGroups() throws DataAccessException {
    final LinkedHashMap<Object, TagContainer> ht = new LinkedHashMap<>();
    final GroupManager groupManager = new BibliographicGroupManager();

    tags.forEach(tag -> {
      final TagGroup group = groupManager.getGroup(tag);
      if (group == null) {
        ht.put(tag, new UniqueTagContainer(tag));
      } else {
        TagContainer tc = ht.get(group);
        if (tc == null) {
          tc = new MultiTagContainer();
          ht.put(group, tc);
        }
        tc.add(tag);
      }
    });
    return ht;
  }


  /**
   * Validates, check mandatory and repeatability tags.
   *
   * @throws ValidationException in case of validation exception.
   * @throws DataAccessException in case of data access exception.
   */
  public void validate() throws ValidationException, DataAccessException {
    checkForMandatoryTags();
    for (int i = 0; i < getTags().size(); i++) {
      checkRepeatability(i);
      getTag(i).validate(i);
    }
  }

}
